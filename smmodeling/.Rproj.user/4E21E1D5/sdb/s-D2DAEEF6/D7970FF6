{
    "contents" : "\n#' @title replace.negative\n#' @description Replaces negative values with 0\n#' @return data.frame\n#' @export\nreplace.negative <- function(data, depths) {\n  for(i in depths) {\n    y <- data[[i]]\n    y[y < 0] <- 0\n    data[[i]] <- y\n  }\n  data\n}\n\n#' @title drop.na\n#' @description Removes NA values from different depths\n#' @return data.frame\n#' @export\ndrop.na <- function(data, depths) {\n  for(i in depths) {\n    data <- data[!is.na(data[[i]]), ]\n  }\n  data\n}\n\n#' @title smooth.stl.remainder\n#' @name smooth.stl.remainder\n#' @description \\cr\n#' Uses STL remainder threshold approach to \n#' calculate smoothed signal. \n#' TODO: Add equation\n#' Make sure data doesn't have na \\cr\n#' \\link{stl}\n#' @return smoothed data vector\n#' @export\nsmooth.stl.remainder <- function(data, depth) {\n  y <- data[[depth]]\n  ysplit <- y\n  \n  time.diff <- difftime(data$date[2], data$date[1], \n                        units=\"mins\")\n  \n  time.diff <- as.numeric(time.diff, units=\"mins\")\n  \n  ysplit.ts <- ts(ysplit, frequency=24 * 60 / time.diff)\n  y.stl <- stl(ysplit.ts, s.window='per')\n  \n  plot(y.stl)\n  \n  rem <- y.stl$time.series[,\"remainder\"]\n  threshold <- mean(rem) + 2 * sd(rem)\n  above <- which(rem > threshold)\n  y.new <- y.stl$time.series[,\"trend\"]\n  y.new[above] <- y[above]\n    \n  data.sm <- data\n  data.sm[[depth]] <-as.numeric(y.new)\n  data.sm\n}\n\n#' @title optimize.stl\n#' @description Optimizes STL with GA using #{equation} \n#' optimization function\n#' @import GA\n#' @export\n#' @param data Soil moisture and rainfall data\n#' @param depth Soil moisture depth to smooth\n#' @param weights Weights for objective function\n#' TODO: add equation\n#' @return STL object\noptimize.stl <- function(data, depth, \n                         weights=c(20, 10, 30),\n                         minparams=c(7, 7, 721),\n                         maxparams=c(99, 99, 801),...) {\n  MinParams <- minparams\n  MaxParams <- maxparams\n  iters <- 50\n  time.diff <- difftime(data$date[2], data$date[1], \n                        units=\"mins\")\n  \n  time.diff <- as.numeric(time.diff, units=\"mins\")\n  \n  poly.smooth <- function(data, depth) {\n    y <- data[[depth]]\n    intervals <- findInterval(data$rainfall, c(0,1))\n    index <- 1\n    while(index < length(intervals)) {\n      startIndex <- index\n      \n      while(index < length(intervals) \n            && intervals[index] != 2) {\n        index <- index + 1\n      }\n      \n      ysplit <- y[startIndex:index]\n      chunk <- data.frame(y=ysplit, x=1:length(ysplit))\n      \n      model <- lm(y ~ stats:::poly(x, 1, raw=TRUE), \n                  data=chunk)\n      \n      y[startIndex:index] <- fitted(model)\n      index <- index + 1\n      \n    }\n    y\n  }\n  \n  y <- data[[depth]]\n  y.ts <- ts(y, frequency=24 * 60 / 20)\n  yhat <- poly.smooth(data, depth)\n  \n  pb <- txtProgressBar(min = 0, max = iters\n                       , style = 3)\n  \n  getStl <- function(params) {\n    y.stl <- stl(y.ts, s.window=params[1],\n                 t.window=params[2],\n                 l.window=params[3],\n                 robust=TRUE)\n    y.stl\n  }\n  \n  evalFunc <- function(params) {\n    y.stl <- getStl(params)\n    r <- as.numeric(y.stl$time.series[,\"remainder\"])\n    y.trend <- as.numeric(y.stl$time.series[,\"trend\"])\n    mse <- sqrt(mean((y.trend - yhat) ^ 2))\n    objective <- sum(c(sd(r), abs(max(r) - min(r)), mse) * weights)\n    -objective\n  }\n  \n  monitorFunc <- function(object) {\n    setTxtProgressBar(pb, object@iter)\n  }\n  \n  GAModel <- ga(type = \"real-valued\", \n                  fitness = evalFunc, \n                  monitor=monitorFunc,\n                  min = MinParams, \n                  max = MaxParams,\n                  maxiter=iters)\n\n  print(GAModel@solution)\n  stl.result <- getStl(GAModel@solution)\n  stl.result\n}\n\n#' @title generate.smoothed\n#' @description creates smoothed data from \n#' seasonality threshold\n#' @param y.stl stl class obtained from optimization\n#' @export\ngenerate.smoothed <- function(y.stl) {\n  mmin <- min(as.numeric(y.stl$time.series[,\"seasonal\"]))\n  mmax <- max(as.numeric(y.stl$time.series[,\"seasonal\"]))\n  y <- as.numeric(y.stl$time.series[,\"trend\"])\n  r <- as.numeric(y.stl$time.series[,\"remainder\"])\n  y[which(r > mmax)] <- y[which(r > mmax)] + r[r > mmax]\n  y[which(r < mmin)] <- y[which(r < mmin)] + r[r < mmin]\n  y\n}\n",
    "created" : 1443671711421.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3713833623",
    "id" : "D7970FF6",
    "lastKnownWriteTime" : 1439498200,
    "path" : "~/Google Drive/USGS-project/code/smmodeling/R/data-manipulation.R",
    "project_path" : "R/data-manipulation.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}